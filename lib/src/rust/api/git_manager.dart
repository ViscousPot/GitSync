// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `_log`, `commit`, `fast_forward`, `fetch_remote_priv`, `get_branch_name_priv`, `get_default_callbacks`, `get_staged_file_paths_priv`, `get_uncommitted_file_paths_priv`, `pull_changes_priv`, `push_changes_priv`, `set_author`, `update_submodules_priv`

Future<void> init({String? homepath}) =>
    RustLib.instance.api.crateApiGitManagerInit(homepath: homepath);

Future<List<String>> getSubmodulePaths({required String pathString}) => RustLib
    .instance
    .api
    .crateApiGitManagerGetSubmodulePaths(pathString: pathString);

Future<void> cloneRepository({
  required String url,
  required String pathString,
  required String provider,
  required (String, String) credentials,
  required (String, String) author,
  required FutureOr<void> Function(String) cloneTaskCallback,
  required FutureOr<void> Function(int) cloneProgressCallback,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerCloneRepository(
  url: url,
  pathString: pathString,
  provider: provider,
  credentials: credentials,
  author: author,
  cloneTaskCallback: cloneTaskCallback,
  cloneProgressCallback: cloneProgressCallback,
  log: log,
);

Future<void> unstageAll({
  required String pathString,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerUnstageAll(
  pathString: pathString,
  log: log,
);

Future<List<Commit>> getRecentCommits({
  required String pathString,
  required String remoteName,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerGetRecentCommits(
  pathString: pathString,
  remoteName: remoteName,
  log: log,
);

Future<void> updateSubmodules({
  required String pathString,
  required String provider,
  required (String, String) credentials,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerUpdateSubmodules(
  pathString: pathString,
  provider: provider,
  credentials: credentials,
  log: log,
);

Future<bool?> fetchRemote({
  required String pathString,
  required String remote,
  required String provider,
  required (String, String) credentials,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerFetchRemote(
  pathString: pathString,
  remote: remote,
  provider: provider,
  credentials: credentials,
  log: log,
);

Future<bool?> pullChanges({
  required String pathString,
  required String provider,
  required (String, String) credentials,
  (String, String)? commitSigningCredentials,
  required FutureOr<void> Function() syncCallback,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerPullChanges(
  pathString: pathString,
  provider: provider,
  credentials: credentials,
  commitSigningCredentials: commitSigningCredentials,
  syncCallback: syncCallback,
  log: log,
);

Future<bool?> downloadChanges({
  required String pathString,
  required String remote,
  required String provider,
  required (String, String) credentials,
  (String, String)? commitSigningCredentials,
  required (String, String) author,
  required FutureOr<void> Function() syncCallback,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerDownloadChanges(
  pathString: pathString,
  remote: remote,
  provider: provider,
  credentials: credentials,
  commitSigningCredentials: commitSigningCredentials,
  author: author,
  syncCallback: syncCallback,
  log: log,
);

Future<bool?> pushChanges({
  required String pathString,
  required String remoteName,
  required String provider,
  required (String, String) credentials,
  required FutureOr<void> Function() mergeConflictCallback,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerPushChanges(
  pathString: pathString,
  remoteName: remoteName,
  provider: provider,
  credentials: credentials,
  mergeConflictCallback: mergeConflictCallback,
  log: log,
);

Future<void> stageFilePaths({
  required String pathString,
  required List<String> paths,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerStageFilePaths(
  pathString: pathString,
  paths: paths,
  log: log,
);

Future<void> unstageFilePaths({
  required String pathString,
  required List<String> paths,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerUnstageFilePaths(
  pathString: pathString,
  paths: paths,
  log: log,
);

Future<int?> getRecommendedAction({
  required String pathString,
  required String remoteName,
  required String provider,
  required (String, String) credentials,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerGetRecommendedAction(
  pathString: pathString,
  remoteName: remoteName,
  provider: provider,
  credentials: credentials,
  log: log,
);

Future<void> commitChanges({
  required String pathString,
  (String, String)? commitSigningCredentials,
  required (String, String) author,
  required String syncMessage,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerCommitChanges(
  pathString: pathString,
  commitSigningCredentials: commitSigningCredentials,
  author: author,
  syncMessage: syncMessage,
  log: log,
);

Future<bool?> uploadChanges({
  required String pathString,
  required String remoteName,
  required String provider,
  required (String, String) credentials,
  (String, String)? commitSigningCredentials,
  required (String, String) author,
  List<String>? filePaths,
  required String syncMessage,
  required FutureOr<void> Function() syncCallback,
  required FutureOr<void> Function() mergeConflictCallback,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerUploadChanges(
  pathString: pathString,
  remoteName: remoteName,
  provider: provider,
  credentials: credentials,
  commitSigningCredentials: commitSigningCredentials,
  author: author,
  filePaths: filePaths,
  syncMessage: syncMessage,
  syncCallback: syncCallback,
  mergeConflictCallback: mergeConflictCallback,
  log: log,
);

Future<void> forcePull({
  required String pathString,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerForcePull(
  pathString: pathString,
  log: log,
);

Future<void> forcePush({
  required String pathString,
  required String remoteName,
  required String provider,
  required (String, String) credentials,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerForcePush(
  pathString: pathString,
  remoteName: remoteName,
  provider: provider,
  credentials: credentials,
  log: log,
);

Future<void> uploadAndOverwrite({
  required String pathString,
  required String remoteName,
  required String provider,
  required (String, String) credentials,
  (String, String)? commitSigningCredentials,
  required (String, String) author,
  required String syncMessage,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerUploadAndOverwrite(
  pathString: pathString,
  remoteName: remoteName,
  provider: provider,
  credentials: credentials,
  commitSigningCredentials: commitSigningCredentials,
  author: author,
  syncMessage: syncMessage,
  log: log,
);

Future<void> downloadAndOverwrite({
  required String pathString,
  required String remoteName,
  required String provider,
  required (String, String) credentials,
  required (String, String) author,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerDownloadAndOverwrite(
  pathString: pathString,
  remoteName: remoteName,
  provider: provider,
  credentials: credentials,
  author: author,
  log: log,
);

Future<void> discardChanges({
  required String pathString,
  required List<String> filePaths,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerDiscardChanges(
  pathString: pathString,
  filePaths: filePaths,
  log: log,
);

Future<List<String>> getConflicting({
  required String pathString,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerGetConflicting(
  pathString: pathString,
  log: log,
);

Future<List<(String, int)>> getStagedFilePaths({
  required String pathString,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerGetStagedFilePaths(
  pathString: pathString,
  log: log,
);

Future<List<(String, int)>> getUncommittedFilePaths({
  required String pathString,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerGetUncommittedFilePaths(
  pathString: pathString,
  log: log,
);

Future<void> abortMerge({
  required String pathString,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerAbortMerge(
  pathString: pathString,
  log: log,
);

Future<(String, String)> generateSshKey({
  required String format,
  required String passphrase,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerGenerateSshKey(
  format: format,
  passphrase: passphrase,
  log: log,
);

Future<String?> getBranchName({
  required String pathString,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerGetBranchName(
  pathString: pathString,
  log: log,
);

Future<List<String>> getBranchNames({
  required String pathString,
  required String remote,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerGetBranchNames(
  pathString: pathString,
  remote: remote,
  log: log,
);

Future<void> checkoutBranch({
  required String pathString,
  required String remote,
  required String branchName,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerCheckoutBranch(
  pathString: pathString,
  remote: remote,
  branchName: branchName,
  log: log,
);

Future<bool> getDisableSsl({required String gitDir}) =>
    RustLib.instance.api.crateApiGitManagerGetDisableSsl(gitDir: gitDir);

Future<void> setDisableSsl({required String gitDir, required bool disable}) =>
    RustLib.instance.api.crateApiGitManagerSetDisableSsl(
      gitDir: gitDir,
      disable: disable,
    );

Future<void> createBranch({
  required String pathString,
  required String newBranchName,
  required String remoteName,
  required String provider,
  required (String, String) credentials,
  required String sourceBranchName,
  required FutureOr<void> Function(LogType, String) log,
}) => RustLib.instance.api.crateApiGitManagerCreateBranch(
  pathString: pathString,
  newBranchName: newBranchName,
  remoteName: remoteName,
  provider: provider,
  credentials: credentials,
  sourceBranchName: sourceBranchName,
  log: log,
);

class Commit {
  final PlatformInt64 timestamp;
  final String author;
  final String reference;
  final String commitMessage;
  final int additions;
  final int deletions;
  final bool unpulled;
  final bool unpushed;

  const Commit({
    required this.timestamp,
    required this.author,
    required this.reference,
    required this.commitMessage,
    required this.additions,
    required this.deletions,
    required this.unpulled,
    required this.unpushed,
  });

  @override
  int get hashCode =>
      timestamp.hashCode ^
      author.hashCode ^
      reference.hashCode ^
      commitMessage.hashCode ^
      additions.hashCode ^
      deletions.hashCode ^
      unpulled.hashCode ^
      unpushed.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Commit &&
          runtimeType == other.runtimeType &&
          timestamp == other.timestamp &&
          author == other.author &&
          reference == other.reference &&
          commitMessage == other.commitMessage &&
          additions == other.additions &&
          deletions == other.deletions &&
          unpulled == other.unpulled &&
          unpushed == other.unpushed;
}

enum LogType {
  global,
  accessibilityService,
  sync_,
  gitStatus,
  abortMerge,
  commit,
  getRepos,
  cloneRepo,
  selectDirectory,
  pullFromRepo,
  pushToRepo,
  forcePull,
  forcePush,
  recentCommits,
  stage,
  syncException,
}
